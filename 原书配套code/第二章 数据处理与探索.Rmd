---
title: "第二章 数据处理与探索"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


数据探索是数据科学过程中非常重要，也是数据可视化中非常关键的一个步骤，只有清晰，完整的数据，才能够对于数据中蕴藏的数据进行良好的展示。数据探索是非常耗时的一个过程，这些过程包括了数据的清洗，数据的转换等过程。tidyverse提供了完整的数据科学的流程，使用tidyverse可以非常方便的进行数据相关的处理。


# 数据转换

在对数据尽心可视化，对数据进行分析之前，常常需要对数据进行各种的转换，以将数据转变成为整洁的数据。tidyverse包中的子包dplyr提供了很多函数对于数据集进行各种各样的处理。dplyr是tidyverse中非常重要的一个包，在对数据进行可视化，建模之前，往往会对数据集使用dplyr包进行处理。

dplyr包有几个关键的函数，这些函数囊括了数据转换的全部功能。这些函数包括：filter，arrange，select，mutate，summarize。其中filter函数用于筛选数据的行；arrange函数用于对数据进行排序；select函数用于筛选数据的列；mutate函数用于生成新的变量。summarize函数用于计算数据的一些统计指标。

另外一个比较常用的函数式group_by函数，这个函数常常被用于对数据进行分组汇总计算。


## 筛选数据的行

第一个要介绍的函数是filter函数，filter函数用于筛选数据集的行，用于创建一个关于数据集的子集。filter函数的第一个参数是需要处理的数据集。第二个参数是筛选数据集的条件。
```{r}
require(tidyverse) # 加载相关的包
iris %>% filter(Sepal.Length > 3) %>% head(3) # 筛选数据集
```

上面的代码中筛选了数据集iris，筛选的条件是Sepal.Length > 3。然后输出了筛选数据集的前三行。如果筛选的条件需要是多个那么有两种方式可以实现，第一种是将不同的条件通过逗号进行分割，这样filter函数则会返回出满足所有条件的数据子集：
```{r}
iris %>% filter(Sepal.Length > 3,Sepal.Width>3) %>% head(3) # 筛选数据集
```

上面的代码设置了两个条件，同时满足这两个条件的数据集会被筛选出来，这种方式只适合‘且’的条件，也就是同时满足所有条件。如果要求是满足部分条件，例如筛选出Sepal.Length>3或者Sepal.Width>3的数据集，这个时候则需要使用另外一种方式，使用逻辑符号。逻辑符号中，‘&’表示且，‘|’表示或。如果想要筛选Sepal.Length>3或者Sepal.Width>3的数据集，则可以使用如下代码：
```{r}
iris %>% filter(Sepal.Length > 3|Sepal.Width>3) %>% head(3) # 筛选数据集
```

以上是对行进行筛选的最常用的方式。另外，在这里总结一下常用的逻辑判断方式：

1. ！ ：表示否等，‘!=’表示不等于
2. %in% :表示是否在某一项向量中,例如，1 %in% c(1,2,3)，返回是TRUE
3. %nin% :表示某一个值是否不再某一个向量中，例如， 1 %nin%% c(1,2,3)返回的是FALSE，需要注意的是，想要使用这个方法进行判断，需要加载Hmise包
4. & ：表示并且
5. | ：表示或者

上面介绍另外一些比较常用的对行的操作，上面总结的判断方式也常常被用于数据集的筛选过程中，常用的函数总结如下：

 
1. distinct : 去除重复的数据集
2. sample_frac  :根据比例对于数据集进行抽样
3. sample_n : 随机抽取一定的样本数量
4. slice ：根据数据集的行数抽取数据
5. top_n ：抽取数据集的前多少行

上面的函数在数据筛选的过程中同样被经常的使用到，下面介绍上述五个函数的使用方式：

distinct函数有三个参数，函数的定义形式为：```distinct(.data, ..., .keep_all = FALSE)```。第一个参数为data，表示需要处理的数据集。第二个参数是...,这是函数中的一个特殊的参数，表示将data参数之后的参数都作为参数输入，‘...’这个参数在不确定函数会输入几个参数的时候非常用用。keep_all参数用于指定是否保留所有的列。下面举一个简单的例子来说明distinct函数的使用方式：

```{r}
tmp <- data.frame(a = c(1,1,2,3,3),b = c(2,3,4,5,5)) # 创建数据框
tmp
```

上面的代码中创建了一个简单的数据集，有两个变量。接下来使用distinct函数进行去重。首先根据变量a进行去除。
```{r}
tmp %>% distinct(a) # 对于数据进行去除重复数据
```

上面的代码根据对数据集的a变量进行了去重，并且distinct函数返回了变量a去重之后的结果。如果想要返回的是根据a去重之后数据集所有变量的结果，需要制定参数.keep_all=TRUE：
```{r}
tmp %>% distinct(a,.keep_all=TRUE) # 对数据集进行去重
```

上面的代码根据a变量进行了去重，去除了a变量中重复的所有行，然后将剩下的数据作为结果返回。从结果中可以看到，b变量还有重复的数据，如果想要对于多个变量进行去重，调用多次distinct函数:
```{r}
tmp %>% distinct(a,.keep_all = T) %>% distinct(b,.keep_all = T) # 对两个变量进行去重
```
上面的代码分别对于a变量和b变量进行了去重，这样的话，每一个变量中都不带有重复的数据。但是还有另外另外一种情况，有一个数据集收集了人们的身份信息，包括姓名，身份证等等，如果要去重则不能单独根据姓名一个变量去重，而是姓名和身份证号码都重复了才认为是重复的。对于上面的例子，就是希望删除a变量和b变量同时一样的数据，实现的代码如下：
```{r}
tmp %>% distinct(a,b,.keep_all=TRUE) # 对两个变量进行去重
```

上面的代码删除了a变量和b变量同时相同的数据。上面的代码等价于```distinct(tmp)```,默认对所有的变量进行去重。上面的方法对于数据集进行去重，几乎所有的去重要求都可以通过上面的方法实现。

另外比较常用的函数是抽样函数，当我们需要对于数据集进行取子集的时候则可以使用，这些抽样函数包括sample_n,sample_frac.sample_fra函数用于对数据集合根据比例进行抽取：
```{r}
dim(iris) # 查看数据的维度

sample_frac(tbl = iris,size = 0.2,replace = F) %>% dim() # 抽取数据 - 根据比例
```

上面的代码对于iris数据集进行了抽样，sample_frac函数的第一个参数是所需要抽样的数据集，第二个参数是数据集的比例大小，是0-1中间的一个数值。replace函数用于指定是否进行又放回的抽样，第四个参数是weight，默认情况下所有行的数据的权重是一样的，意味着所有数据被抽取的可能性是一样的，如果不选择默认，weight必须等于一个与输入长度相同的非负数向量。权重自动标准化为1。sample_n函数用于直接抽取数据集的行：
```{r}
sample_n(tbl = iris,size = 30,replace = F) %>% dim() # 抽取数据-根据数量
```

上面的代码与之前的代码是等价的，之前的代码```sample_frac(tbl = iris,size = 0.2,replace = F)```表明抽取数据集的20%的数据，也就是30条数据。后面的代码直接指定抽取30条数据。这就意味着最终两种方式都是抽取了30条数据及。


slice函数用于根据数据集的行来抽取数据，假设想要抽取数据集的前10行的数据，或者想要中间某个范围的数据，则可以使用slice函数：
```{r}
iris %>% slice(5:10) # 选取数据集合的前十行

```

上面的代码用于抽取了iris数据集中第五行到第十行的数据集.其实使用filter函数同样可以实现这样的功能。上面的代码等价于：
```{r}
iris %>% filter(row_number()<=10,row_number()>=5) # 数据筛选
```

上面的代码同样抽取了iris数据集中第五行到第十行的数据。使用了filter函数，其中row_number代表了数据集的行，通过逻辑运算选取行数小于10，大于5的行，则可以得出想要的结果。需要注意的是row_number代表数据集的行，n()代表数据集的最大行数。

最后,top_n函数会根据数据的排序来抽取数据，常常用于抽取数据集中最大的一部分数据，例如，想要抽出数据集中身高最高的前十条数据，则使用这个函数会非常的方便，下面抽取iris数据集中Sepal.Width最大的前3条数据：
```{r}
top_n(iris, 3, Sepal.Width) # 选取数据集前一部分数据
```
上面的代码中抽取可iris数据集中Sepal.Width最大的前三条数据。tmo_n函数第一个参数是需要处理的数据集，第二个参数是想要抽取的行数，第三个特征表明根据哪个变量进行抽取。另外，tmp_n函数也常常和group_by函数一起使用，group_by函数用于对数据进行分组。假如，想要抽取不同性别，身高最高的前三条数据，使用group_by和top_n可以非常方便的实现：
```{r}
iris %>% group_by(Species) %>% top_n(1,Petal.Width) # 对数据进行分组
```

上面的代码根据不同的物种(Species)，进行分组，然后分别抽取每个组里面Petal.Width变量最大的数据。

以上的内容是关于对数据的行进行筛选。接下来介绍对数据集的列进行处理。

## 筛选数据的列

如果数据集中存在非常多的列，那么可以使用select函数可以直接筛选出需要的列。最长的使用方式是根据变量名字进行选取：
```{r}
iris %>% dplyr::select(Sepal.Length)  %>% head(3) # 选择变量
```

上面的代码筛选出了iris数据集中，列名为Sepal.Length的列。如果想要的并不是某些列，而是想要删除某些列，则可以在变量名前面加上一个'-'，用减号表明删除这个列。
```{r}
iris %>% dplyr::select(-Sepal.Length)  %>% head(3) # 删除某个变量，选取剩下的数据集
```

上面的代码删除了Sepal.Length这一些，将剩下的数据保存下来。另外，有几个在筛选列的时候非常常用的辅助函数，这些函数包括：

1. starts_with ：匹配以某一字符串开头的行
2. ends_with ： 匹配以某一字符串结尾的行
3. contains ：用于匹配字符串
4. matches :用于匹配正则表达式

上面总结的四个函数在筛选行的时候回被经常的使用到，当我们想要以某一字符串开头的所有的列的时候，可以使用starts_with函数，例如对于iris数据集，想要筛选Petal开头的数据集:
```{r}
iris %>% dplyr::select(starts_with("Petal")) # 选取以Petal开头的变量
```
 
上面的代码筛选出了以Petal开头的所有的特征。同理使用ends_with特征可以筛选出所有以某一字符串结尾的特征，例如对于iris数据集，筛选出所有以Length结尾的特征：
```{r}
iris %>% dplyr::select(ends_with("Length")) # 选取以Length结尾的变量
```

上面的代码筛选出了iris数据集中所有以Length字符串结尾的变量。另外，如果想要筛选变量名包含某些字符的变量，则可以使用contain函数，例如，筛选出所有包含Se的变量：
```{r}
iris %>% dplyr::select(contains(c("Se"))) # 筛选变量名包含Se的变量
```

上面的代码中筛选出了字符串中包含Se的变量。更普遍的情况是，想要通过正则表达式来进行匹配，这个时候则需要使用matches函数，假设要筛选出包含'.c.',这个正则表达式的变量，则可以：
```{r}
iris %>% dplyr::select(matches('.c.')) # 通过正则表达是筛选变量
```

上面的代码筛选出了Species，而代码中正则表达式的含义是筛选出字符串中所有包含‘c’的变量。以上是对于数据集的列进行操作。接下来介绍如果对于数据集进行排序。

## 数据排序以及新变量生成

对数据及进行排序是数据处理的过程中非常常见的操作。R中默认的排序函数有三个，分别是order函数，sort函数和rank函数。这里介绍对数据进行排序更友好的一种方式，是来自dplyr包中的arrange函数。函数的第一个参数为需要处理的数据集，其他的参数是需要排序的变量。下面对iris数据集根据Petal.Width特征进行排序：

```{r}
iris %>% arrange(Petal.Width) %>% head(3) # 对数据集进行排序
```

上面的代码对于iris数据集进行排序，排序的特征是Petal.Width。排序的方式是升序排序。如果想要降序排序，则需要使用desc函数：
```{r}
iris %>% arrange(desc(Petal.Width)) %>% head(3) # 对数据集进行降序排序
```
上面的代码对于iris数据集进行排序，排序的特征是Petal.Width。排序的方式是升序排序。如果想要升序排序。如果希望根据多个变量进行排序，实现的方式非常简单，只需要指定多个排序变量即可：
```{r}
iris %>% arrange(desc(Petal.Width),Petal.Length) %>% head(3) # 对两个变量进行排序
```

上面的代码根据多个变量进行排序，首先根据Petal.Width变量进行降序排序，然后根据Petal.Length变量进行升序进行排序，最后返回排序之后的数据集。

以上是关于数据探索中排序相关的操作。在数据探索中，往往还涉及到新变量的生成，例如，想要对数据进行对数转换，将转换之后的数据生成一个新的变量。这个时候需要时mutate函数，这个函数可以再原始的数据集中生成一个新的变量。例如，对iris数据集进行处理，需要计算Sepal.Length与Sepal.Width 的和，并生成一个新的变量，则可以使用mutate函数，代码如下：
```{r}
iris %>% mutate(Sepal = Sepal.Length + Sepal.Width) %>% head(3) # 生成一个新的变量
```

上面的代码计算出来了iris数据集中Sepal.Length和Sepal.Width两个变量的和，并将和的结果生成为Sepal变量。mutate函数的使用方式很简单，变量名 = 变量的公式，设置好了之后调用mutate函数即可，最后返回的结果则会包含新生成的数据集。


## 数据分组汇总

数据的分组也是数据探索的重要的手段，通过对数据不断地分组，可以细化数据的维度，能够更加细致的了解数据。这里对数据分组进行操作的函数是group_by函数，计算统计汇总的函数是summarise函数。首先介绍summarise函数，对于整个数据集使用summarise可以计算关于整个数据集的统计量。例如，计算iris数据集中各个特征的平均值，则可以使用summarise函数：
```{r}
iris %>% summarise(mean(Sepal.Length),mean(Sepal.Width),mean(Petal.Length),mean(Petal.Width)) # 计算数据集的统计量
```


上面的代码中计算了iris数据集中四个连续变量的平均值。summarise函数常常与group_by函数一起使用，用于计算不同组别的统计量。例如，在iris数据集中，一共有三种不同的物种Species,如果想要计算不同物种的平均值，则需要使用group_by函数根据Species进行分组，然后计算平均值：
```{r}
iris %>% group_by(Species) %>% summarise(mean(Sepal.Length),mean(Sepal.Width),mean(Petal.Length),mean(Petal.Width)) # 对数据集进行分组，然后计算分组后数据集的统计量
```
上面的代码中计算出了不同的物种，其Sepal.Length，Sepal.Width，Petal.Length和Petal.Length的平均值。同样，也可以根据多个变量进行分组汇总，实现的方法就是在group_by函数中添加多个变量即可。

## 数据合并

在进行数据探索的过程中，处理的数据集往往不止一个，这个时候就会涉及一些数据表合并相关的工作。数据表合并一般有四种，左连接，右连接，内连接，外连接等等。

左连接表示的是选择表A中的所有记录，以及表B中满足连接条件的记录（如果有的话）。以表A的数据为基准，不管表B有没有对应的数据，下图通过图解的方式解释了左连接。

![](/Users/milin/Downloads/leftjoin.png)

右连接和左连接非常相似，选择表B中的所有记录，以及表A中满足连接条件的记录（如果有的话），下图通过图解的方式解释了右连接：


![](/Users/milin/Downloads/rightjoin.png)

内连接指的是从表A和表B中选择满足连接条件的所有记录。也就是输数据要同时存在于两个表，才会在合并的表中记录下来，下图通过图解的方式解释了右连接：
![](/Users/milin/Downloads/innerjoin.png)

全连接则指的是选择表A和表B中的所有记录，无论是否满足连接条件。也就是说只要是一条数据存在于表A或者表B，则会记录在合并的表中：
![](/Users/milin/Downloads/fulljoin.png)

上面介绍了常见的几种表的合并方式。进行合并操作的函数分别是，left_join,right_join,inner_join,full_join,其对应的分别是左连接，右连接，内连接和外连接。这几个函数的参数都非常的相似，前两个参数分别是需要合并的数据集，第三个参数by用于指定使用什么变量进行合并。这里使用band_members和band_instruments这两个数据集为例子，这两个数据集记录了不同乐队成员以及乐队角色，分别进行这四种合并，首先查看这两个数据集：
```{r}
band_members

band_instruments
```

从数据集的输出可以看到，数据集中都有name这个变量，合并这两个数据集需要通过name这个变量进行合并。下面的代码分别使用四种合并方式进行合并：
```{r}
band_members %>% inner_join(band_instruments,by = "name") # 内链接

```

上面的代码根据name变量对两个数据集进行内连接，连接之后的数据集只保留了两条数据。接下来进行左连接：
```{r}
band_members %>% left_join(band_instruments,by = "name") # 左连接

```
上面的代码进行了左连接，可以看到最后的数据集保留了三条数据，但是第一条数据的plays变量的值为空，这就说明第二张数据表band_instruments并没有name为Mick的这一条数据。接下来进行右连接：
```{r}
band_members %>% right_join(band_instruments,by = "name") # 右连接

```
上面的代码对数据及进行了右连接，从结果中可以看到，合并之后的结果依然有三条数据。但是合并之后的第三条数据的band变量的值为空，这就说明第一张表band_members中，并没有name为Keith的数据。最后进行全连接：
```{r}
band_members %>% full_join(band_instruments,by = "name") # 全连接
```
上面的代码进行了全连接，从结果可以看到，合并之后的数据保留了两张数据表全部的数据，对于数据中有空缺的地方，使用缺失值来表示。以上就是关于数据合并相关的内容。

上面的例子中，两个数据集都有相同的变量，变量名也是一样的。如果变量名不一样，则需要使用另外一种方式实现：
```{r}
band_instruments2

band_members %>% full_join(band_instruments2, by = c("name" = "artist")) # 指定连接的键
```
上面的代码中，band_instruments2的变量名从原来的name改为了artist，这个时候就不能直接通过name进行合并，通过设置by = c("name" = "artist")这种方式来指定使用第一个数据集的name变量与第二个数据集的artist变量进行合并。另外需要提到的是，如果要通过多个变量进行合并，则只需要给by传递一个包含多个变量的向量即可。例如by = c("A","B")。这就表明根据这两个数据集的A变量和B变量进行合并。

需要注意的是，这种合并是列的合并，也就是说，将不同的列合并到一起。如果两个数据集有相同的变量，想把这两个数据集合并一起，这个时候直接将一个数据集合并在另外一个数据及的末尾即可。这个时候需要使用bind_rows函数。用于合并有相同列的数据集：
```{r}
one <- mtcars[1:4, ]
two <- mtcars[11:14, ]


bind_rows(one, two)  # 按照行合并数据集
```

最后需要提到的是关于集合运算，也就是集合的交集，并集，补集。其对应的函数分别是intersect，setdiff和union。其中交集是选取多个个集合相交的不同，如图所示：

![](/Users/milin/Downloads/inter.png)
上图中，圆圈代表的是不同集合，红色部分代表的是集合的相同部分。如果是取集合的交集，则表示选取多个集合中相同的那一部分。

并集指的是选取多个集合的所有部分，也就是说不管相不相交，集合并集的结果指的是多个集合的全部结果，通过图形解释如下：
![](/Users/milin/Downloads/union.png)

最后是差集，两个集合的差集，例如A与B的差集表示的是所有属于A集合的并不属于B的元素的集合。如果用图形表示，则如下图：

![](/Users/milin/Downloads/setdiff.jpeg)

实现这三种集合操作的函数分别是：

1. intersect  ：交集
2. union ：并集
3. setdiff  ：补集

在R中，一般向量可以当做是集合进行处理。下面列举一个小例子来介绍这三种集合运算的使用：
```{r}
A <- c(1,2,3,4,5)
B <- c(2,3,4,5,6)

intersect(A,B) # 交集运算
union(A,B) # 并集运算
setdiff(A,B) # 补集
```

上面的代码首先创建的了两个向量，然后计算了两个向量的交集，并集和补集。集合运算在数据探索过程中也会经常使用到。通过这三个函数可以非常方便的计算集合的交集，并集和补集。

最后，在实际的数据探索过程中，上文提到过的几个方法常常会交替使用，例如，可能在分组之后进行数据的筛选，或者分组之后生成一个新的变量，然后计算统计量。实际的数据探索过程中，会更加的复杂，只不过由于管道操作符的存在，这些数据探索的过程都可以由于管道操作符分割开来。因此在实际操作的过程中，实现复杂的操作并不会很困难。以上就是介绍了关于数据探索的一些基本的实现方法，接下来会介绍数据重塑相关的内容。

# 数据重塑

有的时候，数据集并不能满足分析的需求,数据集并不是整洁的，这个时候需要将数据进行重塑成整洁的数据。什么是整洁的数据格式，整洁的数据格式有三个标准：

1. 没一个变量都有一个唯一的列。
2. 每一个观测都有其唯一的行。
3. 数据集中每一个值都唯一的确定。

![](/Users/milin/写书/tidy.png)


很多情况下，我们遇到的数据集并不是整洁的数据，对数据进行重塑包括几个方面：

1. Gathering ：对数据进行聚集
2. Spreading ：对数据进行分散
3. Separating ：数据切割
4. Uniting ：数据整合

接下来分别介绍数据重塑的这四个方面。

## 数据聚合

在数据处理的过程中常常会遇到的一个问题是，数据中的列名并不是变量，而是变量的值。如下图所示
![](/Users/milin/写书/table4.png)

第二列和第三列分别为1999和2000，这两列并不是变量名，而是变量名的值。因为这两个变量都代表年份，分别是年份的一个值。因此，需要创建一个新的变量代表年份。使用gather函数可以非常方便的实现这种操作。
```{r}
gather(table4a, `1999`, `2000`,
key = "year", value = "cases") # 数据和聚合
```

上面的代码生成了一个新的变量year用于替代原来的1999和2000这两列。变量year的值也变成了1999和2000.另外还生成了一个变量cases，用于记录不同年份下的具体数值。后面这种格式的数据才是数据探索以及数据可视化过程中使用得数据，前一种格式的数据是没有办法直接进行绘图的，因此非常有比较要讲数据集转换成后面这种格式，后面这种格式也被称为整洁的数据。gather的使用方式很简单，第一个参数是需要处理的数据集，后面的变量是数据集中需要压缩的列，参数key用于指定用于表示压缩的列的新变量的变量名。value用于指定原始数据集被压缩之后，新变量的变量名。上面两个数据集的转变过程如图所示：

![](/Users/milin/写书/tidy1.png)


从图中可以看到，1999和2000被压缩成为了一个变量yaer，原数据种不同列的数据被压缩成为了新的变量cases。两个数据集的含义并没有发生任何的改变的，改变的只是数据的结构，而后面这种数据结构是数据可视化中所需要的数据结构。另外，需要注意的是，第一个数据集也被称之为宽数据，因为这个数据往往列比较多，第二个数据被称之为长数据，因为这个数据集行比较多，所以这种转换也被称之为宽数据转换成为长数据。


## 数据分散

在上文中介绍了数据的聚合，数据的聚合是数据重塑的操作中非常重要的一个步骤，数据聚合这种操作也被称之为宽数据转换成为长数据。但是有时需要进行反向操作，也就是将长数据转换成为短数据。也就是数据的分散。这种操作可以使用spread函数进行操作：

![](/Users/milin/写书/table2.png)

上图显示的数据集中，是一份长数据，type 这个变量有两个值，如果想讲type的这两个值分别当做新的变量，形成一份新的数据集，可以进行如下的设置：
```{r}
spread(table2, key = type, value = count) # 数据的分散
```

上面的代码将长数据，转换成为了宽数据。spread函数的第一个参数是需要处理的数据集，第二个参数key表示想要进行处理的变量，这里指定了type变量，表示将type变量的值作为新数据的变量名。value用于指定用哪个变量的值取填充新变量的值。新数据集中，cases，population变量的值就是原始数据中count变量的值。数据集的表达的含义依然没有变化，只是数据的表现形式产生了变化。

![](/Users/milin/写书/tidy3.png)

上图显示了两个数据集的关系。在长数据转换成为宽数据的过程中，长数据的变量的值变成了宽数据的变量。上面介绍了数据的聚合和数据的分散，这两项操作互为逆操作。在数据探索与可视化的过程中，常常会进行这两种操作。

## 数据切割

当我们希望将原始数据中的一列变成多列的时候，此时则需要对数据进行切割。例如，有一个变量为姓名，记录了人们的名字，如果想把姓名这个变量拆封成为姓氏，和名这两个变量的时候，则需要使用数据切割。数据切割所需要使用到的函数为separate。sepatate函数的主要参数有四个，分别包括需要处理的数据集，需要切割的列，新的列名，数据切割的方式。下面以数据集table3进行举例：
```{r}
table3
separate(table3, rate, sep = "/",
into = c("cases", "pop")) # 数据的切割
```

从上面的的结果可以看到，原始数据及table3的rate变量存在‘/’符号。上面的代码将rate变量根据'/'拆分成为两个新的列。上面的代码中，separate函数的第一个参数是需要处理的数据集，第二个参数指定了需要处理的变量，参数sep指定了用于划分数据的分隔符，参数into表明将划分之后的数据变成两个新的变量，cases和pop。数据的关系图如下：

![](/Users/milin/写书/separate.png)

还有另外一种方式，将拆分出来的列作为新的数据，虽然一般使用的并不多，但是偶尔也会使用到。使用到的函数是separate_rows,使用的方式与上一个函数非常相似，只是并不需要指定新的变量名：
```{r}
separate_rows(table3,rate,sep = "/") # 数据的拆分
```

上面的代码同样对于table3数据集中的rate变量进行了拆分，只不过并没将将拆分出来的列作为新的变量，而是将拆分出来的数据作为了新的行。数据的关系图如下所示：
![](/Users/milin/写书/separaterow.png)

## 数据合并

数据切割的逆向操作就是数据合并，如果希望将数据集中的多个列合并起来，则可以使用unite函数,unite函数的第一个参数是需要处理的数据集，第二个参数是需要合并的列，第三个参数是新变量的名称，第四个变量则是分割符的指定：
```{r}
table5
unite(table5, century, year,
col = "year", sep = "") # 数据的合并
```

上面的代码对于table5数据集的century和year两个变量进行了合并，最后生成一个完整的年份。数据集的关系图如下：
![](/Users/milin/写书/unite.png)

# 总结

在本章节介绍了在数据探索过程中经常对数据及进行的处理。通过本章节的内容学习，可以对任何的数据集进行处理，转换成为整洁的数据。本章节的内容包含了数据可视化之前非常关键的一个步骤，也就是将数据转变成为我们想要进行可视化的数据。数据处理相关的内容到本章节为止，在接下来的章节，会介绍更过关于数据可视化方面的内容。